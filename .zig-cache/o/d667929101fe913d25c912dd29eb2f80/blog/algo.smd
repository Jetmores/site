<!DOCTYPE html>
<html>
  <head id="head">
	<meta charset="UTF-8">
	<title id="title">YuHeng&apos;s blog! - Zine</title>
	<link href="/style.css" rel="stylesheet">
  </head>
<body>
	<nav id="menu" class="centered">
		<a href="/">主页</a>
		<a href="/blog/">日志</a>
		<a href="/sample/">用例</a>
	</nav>
	<h1>算法1</h1>
	<div id="content"><h3>算法</h3><ol><li>定义:明确的输入输出,可行的步骤</li><li>循环:</li><li>递归:可借助栈转换为循环,不过代价需要权衡;(尾递归某些编译器可直接优化为循环)</li><li>时间复杂度:运行时间的增长趋势,一般优先时间(明显空间不足时才考虑空间),<br>常数阶O(1)<对数阶O(log n)<线性阶O(n)<线性对数阶O(nlog n)<平方阶O(n^2)<指数阶O(2^n)</li><li>空间复杂度:占用内存空间的增长趋势</li></ol><h3>数组和链表</h3><h4>数组:array</h4><h4>数组的改进-vector/ArrayList动态数组,deque/SegmentedList类似半个deque</h4><h4>链表:list/DoublyLinkedList,forward_list/SinglyLinkedList</h4><h4>链表的改进-跳表</h4><p>xxx</p><h4>数组链表的综合改进-哈希表(散列表)</h4><p>通过建立键key与值value之间的映射,实现高效的元素查询.在哈希表中进行增删改查的时间复杂度都是O(1),非常高效.</p><h5>负载因子load factor</h5><p>哈希表的元素数量除以桶数量,用于衡量哈希冲突的严重程度,也常作为哈希表扩容的触发条件.</p><h5>哈希冲突</h5><p>通常情况下哈希函数的输入空间远大于输出空间,因此理论上哈希冲突是不可避免的.<br>如f(x)=x % 100中137和237就冲突了.</p><ul><li>扩容:粗暴有效,但效率低,仅当哈希冲突比较严重时才扩容</li><li>链式地址:数组中各元素作为桶,冲突时桶内存放链表/红黑树</li><li>开放寻址:都不能直接删除元素,需要懒删除lazy deletion机制来间接删除元素<ul><li>线性探测:冲突时偏移固定步长如1,易产生聚集效应</li><li>平方探测:跳过’探测次数的平方’的步数,即1,2,9…步</li><li>多次哈希:f1,f2,f3…进行探测,不易产生聚集,但会带来额外的计算量</li></ul></li></ul><h5>哈希算法</h5><p>效率高和均匀分布</p><ul><li>加法哈希:</li><li>乘法哈希:</li><li>异或哈希:</li><li>旋转哈希:</li></ul><h3>查找</h3><h4>二分查找:自适应搜索</h4><pre><code class="cpp"><span class="comment">/* 二分查找（左闭右开区间） */</span>
<span class="type">int</span> <span class="function">binarySearchLCRO</span>(<span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">nums</span>, <span class="type">int</span> <span class="variable">target</span>) {
    <span class="comment">// 初始化左闭右开区间 [0, n) ，即 i, j 分别指向数组首元素、尾元素+1</span>
    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, <span class="variable">j</span> <span class="operator">=</span> <span class="variable">nums</span><span class="delimiter">.</span><span class="function">size</span>()<span class="delimiter">;</span>
    <span class="comment">// 循环，当搜索区间为空时跳出（当 i = j 时为空）</span>
    <span class="keyword">while</span> (<span class="variable">i</span> <span class="operator">&lt;</span> <span class="variable">j</span>) {
        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="variable">i</span> <span class="operator">+</span> (<span class="variable">j</span> <span class="operator">-</span> <span class="variable">i</span>) / <span class="number">2</span><span class="delimiter">;</span> <span class="comment">// 计算中点索引 m</span>
        <span class="keyword">if</span> (<span class="variable">nums</span>[<span class="variable">m</span>] <span class="operator">&lt;</span> <span class="variable">target</span>)    <span class="comment">// 此情况说明 target 在区间 [m+1, j) 中</span>
            <span class="variable">i</span> <span class="operator">=</span> <span class="variable">m</span> <span class="operator">+</span> <span class="number">1</span><span class="delimiter">;</span>
        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">nums</span>[<span class="variable">m</span>] <span class="operator">&gt;</span> <span class="variable">target</span>) <span class="comment">// 此情况说明 target 在区间 [i, m) 中</span>
            <span class="variable">j</span> <span class="operator">=</span> <span class="variable">m</span><span class="delimiter">;</span>
        <span class="keyword">else</span> <span class="comment">// 找到目标元素，返回其索引</span>
            <span class="keyword">return</span> <span class="variable">m</span><span class="delimiter">;</span>
    }
    <span class="comment">// 未找到目标元素，返回 -1</span>
    <span class="keyword">return</span> <span class="number">-1</span><span class="delimiter">;</span>
}
</code></pre>
<h4>树查找</h4><p>例如二叉搜索树</p><h4>哈希查找</h4><p>散列表通过散列函数查找</p><h4>线性搜索:暴力搜索(遍历)</h4><h4>深度优先搜索</h4><ul><li>树:先序遍历,中序遍历,后序遍历</li><li>图</li></ul><h4>广度优先搜索</h4><ul><li>树:层序遍历</li><li>图</li></ul><h3>排序</h3><table>
<thead>
<tr>
<th align="center">排序算法</th>
<th align="center">平均复杂度</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">空间复杂度</th>
<th align="center">排序方式</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">插入排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">in-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n^2)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">in-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">冒泡排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">in-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">O(1)</td>
<td align="center">in-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(nlog n)</td>
<td align="center">O(nlog n)</td>
<td align="center">O(nlog n)</td>
<td align="center">O(1)</td>
<td align="center">in-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">O(nlog n)</td>
<td align="center">O(nlog n)</td>
<td align="center">O(n^2)</td>
<td align="center">O(log n)</td>
<td align="center">in-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(nlog n)</td>
<td align="center">O(nlog n)</td>
<td align="center">O(nlog n)</td>
<td align="center">O(n)</td>
<td align="center">out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">O(k)</td>
<td align="center">out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">O(n*k)</td>
<td align="center">O(n*k)</td>
<td align="center">O(n*k)</td>
<td align="center">O(n+k)</td>
<td align="center">out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">O(n^2)</td>
<td align="center">O(n+k)</td>
<td align="center">out-place</td>
<td align="center">稳定</td>
</tr>
</tbody>
</table>
<h4>插入排序(n~n^2~~n^2 stable)</h4><pre><code class="c"><span class="comment">/* 插入排序 */</span>
<span class="type">void</span> <span class="function">insertionSort</span>(<span class="type">int</span> <span class="variable">nums</span>[], <span class="type">int</span> <span class="variable">size</span>) {
    <span class="comment">// 外循环：已排序元素数量为 1, 2, ..., n</span>
    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span><span class="delimiter">;</span> <span class="variable">i</span> <span class="operator">&lt;</span> <span class="variable">size</span><span class="delimiter">;</span> <span class="variable">i</span><span class="operator">++</span>) {
        <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> <span class="variable">nums</span>[<span class="variable">i</span>], <span class="variable">j</span> <span class="operator">=</span> <span class="variable">i</span> <span class="operator">-</span> <span class="number">1</span><span class="delimiter">;</span>
        <span class="comment">// 内循环：将 base 插入到已排序部分的正确位置</span>
        <span class="keyword">while</span> (<span class="variable">j</span> &gt;= <span class="number">0</span> <span class="operator">&amp;&amp;</span> <span class="variable">nums</span>[<span class="variable">j</span>] <span class="operator">&gt;</span> <span class="variable">base</span>) {
            <span class="comment">// 将 nums[j] 向右移动一位</span>
            <span class="variable">nums</span>[<span class="variable">j</span> <span class="operator">+</span> <span class="number">1</span>] <span class="operator">=</span> <span class="variable">nums</span>[<span class="variable">j</span>]<span class="delimiter">;</span>
            <span class="variable">j</span><span class="operator">--</span><span class="delimiter">;</span>
        }
        <span class="comment">// 将 base 赋值到正确位置</span>
        <span class="variable">nums</span>[<span class="variable">j</span> <span class="operator">+</span> <span class="number">1</span>] <span class="operator">=</span> <span class="variable">base</span><span class="delimiter">;</span>
    }
}
</code></pre>
<h4>选择排序</h4><h4>冒泡排序</h4><h4>希尔排序</h4><h4>堆排序3(nlogn~nlogn~~nlogn unstable)</h4><pre><code class="cpp"><span class="comment">/* 堆的长度为 n ，从节点 i 开始，从顶至底堆化 */</span>
<span class="type">void</span> <span class="function">siftDown</span>(<span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">nums</span>, <span class="type">int</span> <span class="variable">n</span>, <span class="type">int</span> <span class="variable">i</span>) {
    <span class="keyword">while</span> (true) {
        <span class="comment">// 判断节点 i, l, r 中值最大的节点，记为 ma</span>
        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2</span> <span class="operator">*</span> <span class="variable">i</span> <span class="operator">+</span> <span class="number">1</span><span class="delimiter">;</span>
        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">2</span> <span class="operator">*</span> <span class="variable">i</span> <span class="operator">+</span> <span class="number">2</span><span class="delimiter">;</span>
        <span class="type">int</span> <span class="variable">ma</span> <span class="operator">=</span> <span class="variable">i</span><span class="delimiter">;</span>
        <span class="keyword">if</span> (<span class="variable">l</span> <span class="operator">&lt;</span> <span class="variable">n</span> <span class="operator">&amp;&amp;</span> <span class="variable">nums</span>[<span class="variable">l</span>] <span class="operator">&gt;</span> <span class="variable">nums</span>[<span class="variable">ma</span>])
            <span class="variable">ma</span> <span class="operator">=</span> <span class="variable">l</span><span class="delimiter">;</span>
        <span class="keyword">if</span> (<span class="variable">r</span> <span class="operator">&lt;</span> <span class="variable">n</span> <span class="operator">&amp;&amp;</span> <span class="variable">nums</span>[<span class="variable">r</span>] <span class="operator">&gt;</span> <span class="variable">nums</span>[<span class="variable">ma</span>])
            <span class="variable">ma</span> <span class="operator">=</span> <span class="variable">r</span><span class="delimiter">;</span>
        <span class="comment">// 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span>
        <span class="keyword">if</span> (<span class="variable">ma</span> <span class="operator">==</span> <span class="variable">i</span>) {
            <span class="keyword">break</span><span class="delimiter">;</span>
        }
        <span class="comment">// 交换两节点</span>
        <span class="function">swap</span>(<span class="variable">nums</span>[<span class="variable">i</span>], <span class="variable">nums</span>[<span class="variable">ma</span>])<span class="delimiter">;</span>
        <span class="comment">// 循环向下堆化</span>
        <span class="variable">i</span> <span class="operator">=</span> <span class="variable">ma</span><span class="delimiter">;</span>
    }
}

<span class="comment">/* 堆排序 */</span>
<span class="type">void</span> <span class="function">heapSort</span>(<span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">nums</span>) {
    <span class="comment">// 建堆操作：堆化除叶节点以外的其他所有节点</span>
    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="variable">nums</span><span class="delimiter">.</span><span class="function">size</span>() / <span class="number">2</span> <span class="operator">-</span> <span class="number">1</span><span class="delimiter">;</span> <span class="variable">i</span> &gt;= <span class="number">0</span><span class="delimiter">;</span> <span class="operator">--</span><span class="variable">i</span>) {
        <span class="function">siftDown</span>(<span class="variable">nums</span>, <span class="variable">nums</span><span class="delimiter">.</span><span class="function">size</span>(), <span class="variable">i</span>)<span class="delimiter">;</span>
    }
    <span class="comment">// 从堆中提取最大元素，循环 n-1 轮</span>
    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="variable">nums</span><span class="delimiter">.</span><span class="function">size</span>() <span class="operator">-</span> <span class="number">1</span><span class="delimiter">;</span> <span class="variable">i</span> <span class="operator">&gt;</span> <span class="number">0</span><span class="delimiter">;</span> <span class="operator">--</span><span class="variable">i</span>) {
        <span class="comment">// 交换根节点与最右叶节点（交换首元素与尾元素）</span>
        <span class="function">swap</span>(<span class="variable">nums</span>[<span class="number">0</span>], <span class="variable">nums</span>[<span class="variable">i</span>])<span class="delimiter">;</span>
        <span class="comment">// 以根节点为起点，从顶至底进行堆化</span>
        <span class="function">siftDown</span>(<span class="variable">nums</span>, <span class="variable">i</span>, <span class="number">0</span>)<span class="delimiter">;</span>
    }
}
</code></pre>
<h4>快速排序1(nlogn~n^2~~nlogn unstable)</h4><p>递归版改为非递归和迭代版:将信息push和pop到栈结构中或者存到范围数组std::pair<int,int> ranges[len];<br> 内省排序(introsort):快排递归深度达到阈值,退化为O(n^2),此时调整为堆排序,从而将最坏情况优化为nlogn;当元素数低于某个阈值,切换为插入排序<br> pdqsort:introsort的改进版</p><pre><code class="cpp"><span class="comment">/* 选取三个元素的中位数 */</span>
<span class="type">int</span> <span class="function">medianThree</span>(<span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">nums</span>, <span class="type">int</span> <span class="variable">left</span>, <span class="type">int</span> <span class="variable">mid</span>, <span class="type">int</span> <span class="variable">right</span>) {
    <span class="comment">// 此处使用异或运算来简化代码</span>
    <span class="comment">// 异或规则为 0 ^ 0 = 1 ^ 1 = 0, 0 ^ 1 = 1 ^ 0 = 1</span>
    <span class="keyword">if</span> ((<span class="variable">nums</span>[<span class="variable">left</span>] <span class="operator">&lt;</span> <span class="variable">nums</span>[<span class="variable">mid</span>]) ^ (<span class="variable">nums</span>[<span class="variable">left</span>] <span class="operator">&lt;</span> <span class="variable">nums</span>[<span class="variable">right</span>]))
        <span class="keyword">return</span> <span class="variable">left</span><span class="delimiter">;</span>
    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="variable">nums</span>[<span class="variable">mid</span>] <span class="operator">&lt;</span> <span class="variable">nums</span>[<span class="variable">left</span>]) ^ (<span class="variable">nums</span>[<span class="variable">mid</span>] <span class="operator">&lt;</span> <span class="variable">nums</span>[<span class="variable">right</span>]))
        <span class="keyword">return</span> <span class="variable">mid</span><span class="delimiter">;</span>
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="variable">right</span><span class="delimiter">;</span>
}

<span class="comment">/* 哨兵划分（三数取中值） */</span>
<span class="type">int</span> <span class="function">partition</span>(<span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">nums</span>, <span class="type">int</span> <span class="variable">left</span>, <span class="type">int</span> <span class="variable">right</span>) {
    <span class="comment">// 选取三个候选元素的中位数</span>
    <span class="type">int</span> <span class="variable">med</span> <span class="operator">=</span> <span class="function">medianThree</span>(<span class="variable">nums</span>, <span class="variable">left</span>, (<span class="variable">left</span> <span class="operator">+</span> <span class="variable">right</span>) / <span class="number">2</span>, <span class="variable">right</span>)<span class="delimiter">;</span>
    <span class="comment">// 将中位数交换至数组最左端</span>
    <span class="function">swap</span>(<span class="variable">nums</span>, <span class="variable">left</span>, <span class="variable">med</span>)<span class="delimiter">;</span>
    <span class="comment">// 以 nums[left] 为基准数</span>
    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="variable">left</span>, <span class="variable">j</span> <span class="operator">=</span> <span class="variable">right</span><span class="delimiter">;</span>
    <span class="keyword">while</span> (<span class="variable">i</span> <span class="operator">&lt;</span> <span class="variable">j</span>) {
        <span class="keyword">while</span> (<span class="variable">i</span> <span class="operator">&lt;</span> <span class="variable">j</span> <span class="operator">&amp;&amp;</span> <span class="variable">nums</span>[<span class="variable">j</span>] &gt;= <span class="variable">nums</span>[<span class="variable">left</span>])
            <span class="variable">j</span><span class="operator">--</span><span class="delimiter">;</span> <span class="comment">// 从右向左找首个小于基准数的元素</span>
        <span class="keyword">while</span> (<span class="variable">i</span> <span class="operator">&lt;</span> <span class="variable">j</span> <span class="operator">&amp;&amp;</span> <span class="variable">nums</span>[<span class="variable">i</span>] &lt;= <span class="variable">nums</span>[<span class="variable">left</span>])
            <span class="variable">i</span><span class="operator">++</span><span class="delimiter">;</span>          <span class="comment">// 从左向右找首个大于基准数的元素</span>
        <span class="function">swap</span>(<span class="variable">nums</span>, <span class="variable">i</span>, <span class="variable">j</span>)<span class="delimiter">;</span> <span class="comment">// 交换这两个元素</span>
    }
    <span class="function">swap</span>(<span class="variable">nums</span>, <span class="variable">i</span>, <span class="variable">left</span>)<span class="delimiter">;</span> <span class="comment">// 将基准数交换至两子数组的分界线</span>
    <span class="keyword">return</span> <span class="variable">i</span><span class="delimiter">;</span>            <span class="comment">// 返回基准数的索引</span>
}

<span class="comment">/* 快速排序 */</span>
<span class="type">void</span> <span class="function">quickSort</span>(<span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">nums</span>, <span class="type">int</span> <span class="variable">left</span>, <span class="type">int</span> <span class="variable">right</span>) {
    <span class="comment">// 子数组长度为 1 时终止递归</span>
    <span class="keyword">if</span> (<span class="variable">left</span> &gt;= <span class="variable">right</span>)
        <span class="keyword">return</span><span class="delimiter">;</span>
    <span class="comment">// 哨兵划分</span>
    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> <span class="function">partition</span>(<span class="variable">nums</span>, <span class="variable">left</span>, <span class="variable">right</span>)<span class="delimiter">;</span>
    <span class="comment">// 递归左子数组、右子数组</span>
    <span class="function">quickSort</span>(<span class="variable">nums</span>, <span class="variable">left</span>, <span class="variable">pivot</span> <span class="operator">-</span> <span class="number">1</span>)<span class="delimiter">;</span>
    <span class="function">quickSort</span>(<span class="variable">nums</span>, <span class="variable">pivot</span> <span class="operator">+</span> <span class="number">1</span>, <span class="variable">right</span>)<span class="delimiter">;</span>
}

<span class="comment">/* 快速排序（尾递归优化） */</span>
<span class="type">void</span> <span class="function">quickSort</span>(<span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">nums</span>, <span class="type">int</span> <span class="variable">left</span>, <span class="type">int</span> <span class="variable">right</span>) {
    <span class="comment">// 子数组长度为 1 时终止</span>
    <span class="keyword">while</span> (<span class="variable">left</span> <span class="operator">&lt;</span> <span class="variable">right</span>) {
        <span class="comment">// 哨兵划分操作</span>
        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> <span class="function">partition</span>(<span class="variable">nums</span>, <span class="variable">left</span>, <span class="variable">right</span>)<span class="delimiter">;</span>
        <span class="comment">// 对两个子数组中较短的那个执行快速排序</span>
        <span class="keyword">if</span> (<span class="variable">pivot</span> <span class="operator">-</span> <span class="variable">left</span> <span class="operator">&lt;</span> <span class="variable">right</span> <span class="operator">-</span> <span class="variable">pivot</span>) {
            <span class="function">quickSort</span>(<span class="variable">nums</span>, <span class="variable">left</span>, <span class="variable">pivot</span> <span class="operator">-</span> <span class="number">1</span>)<span class="delimiter">;</span> <span class="comment">// 递归排序左子数组</span>
            <span class="variable">left</span> <span class="operator">=</span> <span class="variable">pivot</span> <span class="operator">+</span> <span class="number">1</span><span class="delimiter">;</span>                 <span class="comment">// 剩余未排序区间为 [pivot + 1, right]</span>
        } <span class="keyword">else</span> {
            <span class="function">quickSort</span>(<span class="variable">nums</span>, <span class="variable">pivot</span> <span class="operator">+</span> <span class="number">1</span>, <span class="variable">right</span>)<span class="delimiter">;</span> <span class="comment">// 递归排序右子数组</span>
            <span class="variable">right</span> <span class="operator">=</span> <span class="variable">pivot</span> <span class="operator">-</span> <span class="number">1</span><span class="delimiter">;</span>                 <span class="comment">// 剩余未排序区间为 [left, pivot - 1]</span>
        }
    }
}
</code></pre>
<h4>归并排序2(nlogn~nlogn~~nlogn stable)</h4><p>块排序(block sort):混合插入和归并的排序</p><pre><code class="cpp"><span class="comment">/* 合并左子数组和右子数组 */</span>
<span class="type">void</span> <span class="function">merge</span>(<span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">nums</span>, <span class="type">int</span> <span class="variable">left</span>, <span class="type">int</span> <span class="variable">mid</span>, <span class="type">int</span> <span class="variable">right</span>) {
    <span class="comment">// 左子数组区间 [left, mid], 右子数组区间 [mid+1, right]</span>
    <span class="comment">// 创建一个临时数组 tmp ，用于存放合并后的结果</span>
    <span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="variable">tmp</span>(<span class="variable">right</span> <span class="operator">-</span> <span class="variable">left</span> <span class="operator">+</span> <span class="number">1</span>)<span class="delimiter">;</span>
    <span class="comment">// 初始化左子数组和右子数组的起始索引</span>
    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="variable">left</span>, <span class="variable">j</span> <span class="operator">=</span> <span class="variable">mid</span> <span class="operator">+</span> <span class="number">1</span>, <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span><span class="delimiter">;</span>
    <span class="comment">// 当左右子数组都还有元素时，比较并将较小的元素复制到临时数组中</span>
    <span class="keyword">while</span> (<span class="variable">i</span> &lt;= <span class="variable">mid</span> <span class="operator">&amp;&amp;</span> <span class="variable">j</span> &lt;= <span class="variable">right</span>) {
        <span class="keyword">if</span> (<span class="variable">nums</span>[<span class="variable">i</span>] &lt;= <span class="variable">nums</span>[<span class="variable">j</span>])
            <span class="variable">tmp</span>[<span class="variable">k</span><span class="operator">++</span>] <span class="operator">=</span> <span class="variable">nums</span>[<span class="variable">i</span><span class="operator">++</span>]<span class="delimiter">;</span>
        <span class="keyword">else</span>
            <span class="variable">tmp</span>[<span class="variable">k</span><span class="operator">++</span>] <span class="operator">=</span> <span class="variable">nums</span>[<span class="variable">j</span><span class="operator">++</span>]<span class="delimiter">;</span>
    }
    <span class="comment">// 将左子数组和右子数组的剩余元素复制到临时数组中</span>
    <span class="keyword">while</span> (<span class="variable">i</span> &lt;= <span class="variable">mid</span>) {
        <span class="variable">tmp</span>[<span class="variable">k</span><span class="operator">++</span>] <span class="operator">=</span> <span class="variable">nums</span>[<span class="variable">i</span><span class="operator">++</span>]<span class="delimiter">;</span>
    }
    <span class="keyword">while</span> (<span class="variable">j</span> &lt;= <span class="variable">right</span>) {
        <span class="variable">tmp</span>[<span class="variable">k</span><span class="operator">++</span>] <span class="operator">=</span> <span class="variable">nums</span>[<span class="variable">j</span><span class="operator">++</span>]<span class="delimiter">;</span>
    }
    <span class="comment">// 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间</span>
    <span class="keyword">for</span> (<span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span><span class="delimiter">;</span> <span class="variable">k</span> <span class="operator">&lt;</span> <span class="variable">tmp</span><span class="delimiter">.</span><span class="function">size</span>()<span class="delimiter">;</span> <span class="variable">k</span><span class="operator">++</span>) {
        <span class="variable">nums</span>[<span class="variable">left</span> <span class="operator">+</span> <span class="variable">k</span>] <span class="operator">=</span> <span class="variable">tmp</span>[<span class="variable">k</span>]<span class="delimiter">;</span>
    }
}

<span class="comment">/* 归并排序 */</span>
<span class="type">void</span> <span class="function">mergeSort</span>(<span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">nums</span>, <span class="type">int</span> <span class="variable">left</span>, <span class="type">int</span> <span class="variable">right</span>) {
    <span class="comment">// 终止条件</span>
    <span class="keyword">if</span> (<span class="variable">left</span> &gt;= <span class="variable">right</span>)
        <span class="keyword">return</span><span class="delimiter">;</span> <span class="comment">// 当子数组长度为 1 时终止递归</span>
    <span class="comment">// 划分阶段</span>
    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (<span class="variable">left</span> <span class="operator">+</span> <span class="variable">right</span>) / <span class="number">2</span><span class="delimiter">;</span>    <span class="comment">// 计算中点</span>
    <span class="function">mergeSort</span>(<span class="variable">nums</span>, <span class="variable">left</span>, <span class="variable">mid</span>)<span class="delimiter">;</span>      <span class="comment">// 递归左子数组</span>
    <span class="function">mergeSort</span>(<span class="variable">nums</span>, <span class="variable">mid</span> <span class="operator">+</span> <span class="number">1</span>, <span class="variable">right</span>)<span class="delimiter">;</span> <span class="comment">// 递归右子数组</span>
    <span class="comment">// 合并阶段</span>
    <span class="function">merge</span>(<span class="variable">nums</span>, <span class="variable">left</span>, <span class="variable">mid</span>, <span class="variable">right</span>)<span class="delimiter">;</span>
}
</code></pre>
<h4>计数排序</h4><p>计数排序是桶排序在整型数据下的一个特例</p><h4>基数排序</h4><h4>桶排序</h4><pre><code class="cpp"><span class="comment">/* 桶排序 */</span>
<span class="type">void</span> <span class="function">bucketSort</span>(<span class="type">vector</span><span class="operator">&lt;</span><span class="type">float</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">nums</span>) {
    <span class="comment">// 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素</span>
    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="variable">nums</span><span class="delimiter">.</span><span class="function">size</span>() / <span class="number">2</span><span class="delimiter">;</span>
    <span class="type">vector</span><span class="operator">&lt;</span><span class="type">vector</span><span class="operator">&lt;</span><span class="type">float</span><span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="function">buckets</span>(<span class="type">k</span>)<span class="delimiter">;</span>
    <span class="comment">// 1. 将数组元素分配到各个桶中</span>
    <span class="keyword">for</span> (<span class="type">float</span> <span class="variable">num</span> : <span class="variable">nums</span>) {
        <span class="comment">// 输入数据范围为 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]</span>
        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="variable">num</span> <span class="operator">*</span> <span class="variable">k</span><span class="delimiter">;</span>
        <span class="comment">// 将 num 添加进桶 bucket_idx</span>
        <span class="variable">buckets</span>[<span class="variable">i</span>]<span class="delimiter">.</span><span class="function">push_back</span>(<span class="variable">num</span>)<span class="delimiter">;</span>
    }
    <span class="comment">// 2. 对各个桶执行排序</span>
    <span class="keyword">for</span> (<span class="type">vector</span><span class="operator">&lt;</span><span class="type">float</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">bucket</span> : <span class="variable">buckets</span>) {
        <span class="comment">// 使用内置稳定排序函数，也可以替换成其他稳定排序算法</span>
        <span class="function">stable_sort</span>(<span class="variable">bucket</span><span class="delimiter">.</span><span class="function">begin</span>(), <span class="variable">bucket</span><span class="delimiter">.</span><span class="function">end</span>())<span class="delimiter">;</span>
    }
    <span class="comment">// 3. 遍历桶合并结果</span>
    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span><span class="delimiter">;</span>
    <span class="keyword">for</span> (<span class="type">vector</span><span class="operator">&lt;</span><span class="type">float</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">bucket</span> : <span class="variable">buckets</span>) {
        <span class="keyword">for</span> (<span class="type">float</span> <span class="variable">num</span> : <span class="variable">bucket</span>) {
            <span class="variable">nums</span>[<span class="variable">i</span><span class="operator">++</span>] <span class="operator">=</span> <span class="variable">num</span><span class="delimiter">;</span>
        }
    }
}
</code></pre>
<hr><h3>树</h3><h4>二叉树的遍历与表示</h4><ul><li>完美二叉树(满二叉树):除叶节点外所有节点度(子节点)为2,呈现标准的指数级关系</li><li>完全二叉树:相对满二叉树,仅最底层右边的未填满</li><li>平衡二叉树:任意节点的左子树和右子树的高度之差的绝对值不超过1</li></ul><p>广度优先搜索:层序遍历</p><pre><code class="cpp"><span class="comment">/* 层序遍历 */</span>
<span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="function">levelOrder</span>(<span class="type">TreeNode</span> <span class="operator">*</span><span class="variable">root</span>) {
    <span class="comment">// 初始化队列，加入根节点</span>
    <span class="type">queue</span><span class="operator">&lt;</span><span class="type">TreeNode</span> <span class="operator">*</span><span class="operator">&gt;</span> <span class="variable">queue</span><span class="delimiter">;</span>
    <span class="variable">queue</span><span class="delimiter">.</span><span class="function">push</span>(<span class="variable">root</span>)<span class="delimiter">;</span>
    <span class="comment">// 初始化一个列表，用于保存遍历序列</span>
    <span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="variable">vec</span><span class="delimiter">;</span>
    <span class="keyword">while</span> (!<span class="variable">queue</span><span class="delimiter">.</span><span class="function">empty</span>()) {
        <span class="type">TreeNode</span> <span class="operator">*</span><span class="variable">node</span> <span class="operator">=</span> <span class="variable">queue</span><span class="delimiter">.</span><span class="function">front</span>()<span class="delimiter">;</span>
        <span class="variable">queue</span><span class="delimiter">.</span><span class="function">pop</span>()<span class="delimiter">;</span>              <span class="comment">// 队列出队</span>
        <span class="variable">vec</span><span class="delimiter">.</span><span class="function">push_back</span>(<span class="variable">node</span><span class="operator">-&gt;</span><span class="property">val</span>)<span class="delimiter">;</span> <span class="comment">// 保存节点值</span>
        <span class="keyword">if</span> (<span class="variable">node</span><span class="operator">-&gt;</span><span class="property">left</span> <span class="operator">!=</span> <span class="constant">nullptr</span>)
            <span class="variable">queue</span><span class="delimiter">.</span><span class="function">push</span>(<span class="variable">node</span><span class="operator">-&gt;</span><span class="property">left</span>)<span class="delimiter">;</span> <span class="comment">// 左子节点入队</span>
        <span class="keyword">if</span> (<span class="variable">node</span><span class="operator">-&gt;</span><span class="property">right</span> <span class="operator">!=</span> <span class="constant">nullptr</span>)
            <span class="variable">queue</span><span class="delimiter">.</span><span class="function">push</span>(<span class="variable">node</span><span class="operator">-&gt;</span><span class="property">right</span>)<span class="delimiter">;</span> <span class="comment">// 右子节点入队</span>
    }
    <span class="keyword">return</span> <span class="variable">vec</span><span class="delimiter">;</span>
}
</code></pre>
<p>深度优先搜索:前序,中序,后序遍历;均为O(n)时间复杂度</p><pre><code class="cpp"><span class="comment">/* 前序遍历 */</span>
<span class="type">void</span> <span class="function">preOrder</span>(<span class="type">TreeNode</span> <span class="operator">*</span><span class="variable">root</span>) {
    <span class="keyword">if</span> (<span class="variable">root</span> <span class="operator">==</span> <span class="constant">nullptr</span>)
        <span class="keyword">return</span><span class="delimiter">;</span>
    <span class="comment">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span>
    <span class="variable">vec</span><span class="delimiter">.</span><span class="function">push_back</span>(<span class="variable">root</span><span class="operator">-&gt;</span><span class="property">val</span>)<span class="delimiter">;</span>
    <span class="function">preOrder</span>(<span class="variable">root</span><span class="operator">-&gt;</span><span class="property">left</span>)<span class="delimiter">;</span>
    <span class="function">preOrder</span>(<span class="variable">root</span><span class="operator">-&gt;</span><span class="property">right</span>)<span class="delimiter">;</span>
}

<span class="comment">/* 中序遍历 */</span>
<span class="type">void</span> <span class="function">inOrder</span>(<span class="type">TreeNode</span> <span class="operator">*</span><span class="variable">root</span>) {
    <span class="keyword">if</span> (<span class="variable">root</span> <span class="operator">==</span> <span class="constant">nullptr</span>)
        <span class="keyword">return</span><span class="delimiter">;</span>
    <span class="comment">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span>
    <span class="function">inOrder</span>(<span class="variable">root</span><span class="operator">-&gt;</span><span class="property">left</span>)<span class="delimiter">;</span>
    <span class="variable">vec</span><span class="delimiter">.</span><span class="function">push_back</span>(<span class="variable">root</span><span class="operator">-&gt;</span><span class="property">val</span>)<span class="delimiter">;</span>
    <span class="function">inOrder</span>(<span class="variable">root</span><span class="operator">-&gt;</span><span class="property">right</span>)<span class="delimiter">;</span>
}

<span class="comment">/* 后序遍历 */</span>
<span class="type">void</span> <span class="function">postOrder</span>(<span class="type">TreeNode</span> <span class="operator">*</span><span class="variable">root</span>) {
    <span class="keyword">if</span> (<span class="variable">root</span> <span class="operator">==</span> <span class="constant">nullptr</span>)
        <span class="keyword">return</span><span class="delimiter">;</span>
    <span class="comment">// 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span>
    <span class="function">postOrder</span>(<span class="variable">root</span><span class="operator">-&gt;</span><span class="property">left</span>)<span class="delimiter">;</span>
    <span class="function">postOrder</span>(<span class="variable">root</span><span class="operator">-&gt;</span><span class="property">right</span>)<span class="delimiter">;</span>
    <span class="variable">vec</span><span class="delimiter">.</span><span class="function">push_back</span>(<span class="variable">root</span><span class="operator">-&gt;</span><span class="property">val</span>)<span class="delimiter">;</span>
}
</code></pre>
<p>表示:</p><ul><li>完美二叉树/完全二叉树:i-left(2i+1)-right(2i+2),可用数组表示,典型代表堆排序中的构建大顶堆</li><li>任意二叉树:数组中为叶子的用INT_MAX表示,其它规则同上</li><li>任意树:左孩子右兄弟表示</li></ul><h4>二叉搜索树:增删查时间复杂度均为O(log n),但存在退化为链表风险,此时O(n)</h4><ol><li>对于根节点，左子树中所有节点的值<根节点的值<右子树中所有节点的值</li><li>任意节点的左,右子树也是二叉搜索树</li></ol><p>中序遍历有序:二叉搜索树的中序遍历序列是升序的</p><h4>AVL树:平衡二叉搜索树</h4><h4>红黑树</h4><p>红黑树是一种自平衡二叉查找树,具有良好的效率,可以在O(log n)的时间复杂度下完成增删改查.<br>特性:</p><ul><li>节点是红色或黑色的</li><li>根和叶子都是黑色的</li><li>不能有两个连续的红色节点(代表红色节点的父和子节点都是黑色的)</li><li>从任意节点到叶子经过相同的黑节点(简称黑高)</li></ul><h4>b树(b-树)</h4><h4>b+树</h4><h4>b*树</h4><hr><h3>图</h3><p>分类:</p><ul><li>有向图|无向图:关注和被关注是有方向的,好友是双向的</li><li>有权图|无权图:最短路径</li><li>连通图|非连通图:多起点</li></ul><p>图的表示:</p><ul><li>邻接矩阵:vector<vector<int>> adjMat;</li><li>邻接链表:unordered_map<Vertex *, vector<Vertex *>> adjList;</li></ul><p>图的遍历:</p><ul><li>广度优先</li></ul><pre><code class="cpp"><span class="comment">/* 广度优先遍历 BFS */</span>
<span class="comment">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span>
<span class="type">vector</span><span class="operator">&lt;</span><span class="type">Vertex</span> <span class="operator">*</span><span class="operator">&gt;</span> <span class="function">graphBFS</span>(<span class="type">GraphAdjList</span> <span class="operator">&amp;</span><span class="variable">graph</span>, <span class="type">Vertex</span> <span class="operator">*</span><span class="variable">startVet</span>) {
    <span class="comment">// 顶点遍历序列</span>
    <span class="type">vector</span><span class="operator">&lt;</span><span class="type">Vertex</span> <span class="operator">*</span><span class="operator">&gt;</span> <span class="variable">res</span><span class="delimiter">;</span>
    <span class="comment">// 哈希表，用于记录已被访问过的顶点</span>
    <span class="type">unordered_set</span><span class="operator">&lt;</span><span class="type">Vertex</span> <span class="operator">*</span><span class="operator">&gt;</span> <span class="variable">visited</span> <span class="operator">=</span> {<span class="variable">startVet</span>}<span class="delimiter">;</span>
    <span class="comment">// 队列用于实现 BFS</span>
    <span class="type">queue</span><span class="operator">&lt;</span><span class="type">Vertex</span> <span class="operator">*</span><span class="operator">&gt;</span> <span class="variable">que</span><span class="delimiter">;</span>
    <span class="variable">que</span><span class="delimiter">.</span><span class="function">push</span>(<span class="variable">startVet</span>)<span class="delimiter">;</span>
    <span class="comment">// 以顶点 vet 为起点，循环直至访问完所有顶点</span>
    <span class="keyword">while</span> (!<span class="variable">que</span><span class="delimiter">.</span><span class="function">empty</span>()) {
        <span class="type">Vertex</span> <span class="operator">*</span><span class="variable">vet</span> <span class="operator">=</span> <span class="variable">que</span><span class="delimiter">.</span><span class="function">front</span>()<span class="delimiter">;</span>
        <span class="variable">que</span><span class="delimiter">.</span><span class="function">pop</span>()<span class="delimiter">;</span>          <span class="comment">// 队首顶点出队</span>
        <span class="variable">res</span><span class="delimiter">.</span><span class="function">push_back</span>(<span class="variable">vet</span>)<span class="delimiter">;</span> <span class="comment">// 记录访问顶点</span>
        <span class="comment">// 遍历该顶点的所有邻接顶点</span>
        <span class="keyword">for</span> (<span class="type">auto</span> <span class="variable">adjVet</span> : <span class="variable">graph</span><span class="delimiter">.</span><span class="property">adjList</span>[<span class="variable">vet</span>]) {
            <span class="keyword">if</span> (<span class="variable">visited</span><span class="delimiter">.</span><span class="function">count</span>(<span class="variable">adjVet</span>))
                <span class="keyword">continue</span><span class="delimiter">;</span>            <span class="comment">// 跳过已被访问的顶点</span>
            <span class="variable">que</span><span class="delimiter">.</span><span class="function">push</span>(<span class="variable">adjVet</span>)<span class="delimiter">;</span>        <span class="comment">// 只入队未访问的顶点</span>
            <span class="variable">visited</span><span class="delimiter">.</span><span class="function">emplace</span>(<span class="variable">adjVet</span>)<span class="delimiter">;</span> <span class="comment">// 标记该顶点已被访问</span>
        }
    }
    <span class="comment">// 返回顶点遍历序列</span>
    <span class="keyword">return</span> <span class="variable">res</span><span class="delimiter">;</span>
}
</code></pre>
<ul><li>深度优先</li></ul><pre><code class="cpp"><span class="comment">/* 深度优先遍历 DFS 辅助函数 */</span>
<span class="type">void</span> <span class="function">dfs</span>(<span class="type">GraphAdjList</span> <span class="operator">&amp;</span><span class="variable">graph</span>, <span class="type">unordered_set</span><span class="operator">&lt;</span><span class="type">Vertex</span> <span class="operator">*</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">visited</span>, <span class="type">vector</span><span class="operator">&lt;</span><span class="type">Vertex</span> <span class="operator">*</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">res</span>, <span class="type">Vertex</span> <span class="operator">*</span><span class="variable">vet</span>) {
    <span class="variable">res</span><span class="delimiter">.</span><span class="function">push_back</span>(<span class="variable">vet</span>)<span class="delimiter">;</span>   <span class="comment">// 记录访问顶点</span>
    <span class="variable">visited</span><span class="delimiter">.</span><span class="function">emplace</span>(<span class="variable">vet</span>)<span class="delimiter">;</span> <span class="comment">// 标记该顶点已被访问</span>
    <span class="comment">// 遍历该顶点的所有邻接顶点</span>
    <span class="keyword">for</span> (<span class="type">Vertex</span> <span class="operator">*</span><span class="variable">adjVet</span> : <span class="variable">graph</span><span class="delimiter">.</span><span class="property">adjList</span>[<span class="variable">vet</span>]) {
        <span class="keyword">if</span> (<span class="variable">visited</span><span class="delimiter">.</span><span class="function">count</span>(<span class="variable">adjVet</span>))
            <span class="keyword">continue</span><span class="delimiter">;</span> <span class="comment">// 跳过已被访问的顶点</span>
        <span class="comment">// 递归访问邻接顶点</span>
        <span class="function">dfs</span>(<span class="variable">graph</span>, <span class="variable">visited</span>, <span class="variable">res</span>, <span class="variable">adjVet</span>)<span class="delimiter">;</span>
    }
}

<span class="comment">/* 深度优先遍历 DFS */</span>
<span class="comment">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span>
<span class="type">vector</span><span class="operator">&lt;</span><span class="type">Vertex</span> <span class="operator">*</span><span class="operator">&gt;</span> <span class="function">graphDFS</span>(<span class="type">GraphAdjList</span> <span class="operator">&amp;</span><span class="variable">graph</span>, <span class="type">Vertex</span> <span class="operator">*</span><span class="variable">startVet</span>) {
    <span class="comment">// 顶点遍历序列</span>
    <span class="type">vector</span><span class="operator">&lt;</span><span class="type">Vertex</span> <span class="operator">*</span><span class="operator">&gt;</span> <span class="variable">res</span><span class="delimiter">;</span>
    <span class="comment">// 哈希表，用于记录已被访问过的顶点</span>
    <span class="type">unordered_set</span><span class="operator">&lt;</span><span class="type">Vertex</span> <span class="operator">*</span><span class="operator">&gt;</span> <span class="variable">visited</span><span class="delimiter">;</span>
    <span class="function">dfs</span>(<span class="variable">graph</span>, <span class="variable">visited</span>, <span class="variable">res</span>, <span class="variable">startVet</span>)<span class="delimiter">;</span>
    <span class="keyword">return</span> <span class="variable">res</span><span class="delimiter">;</span>
}
</code></pre>
<hr><h2>分治之后是算法第二阶段,需要更高深的理解力和想象力</h2><h3>分治</h3><p>分而治之揭示了一个重要的事实:从简单做起,一切都不再复杂.<br>分治算法递归地将原问题划分为多个相互独立的子问题,直至最小子问题,并在回溯中合并子问题的解,最终得到原问题的解.<br>应用:</p><ul><li>堆排序,快速排序,归并排序,桶排序</li><li>二分查找,哈希表查找,树(二叉搜索树,红黑树等)</li><li>汉诺塔</li></ul><pre><code class="cpp"><span class="comment">/* 移动一个圆盘 */</span>
<span class="type">void</span> <span class="function">move</span>(<span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">src</span>, <span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">tar</span>) {
    <span class="comment">// 从 src 顶部拿出一个圆盘</span>
    <span class="type">int</span> <span class="variable">pan</span> <span class="operator">=</span> <span class="variable">src</span><span class="delimiter">.</span><span class="function">back</span>()<span class="delimiter">;</span>
    <span class="variable">src</span><span class="delimiter">.</span><span class="function">pop_back</span>()<span class="delimiter">;</span>
    <span class="comment">// 将圆盘放入 tar 顶部</span>
    <span class="variable">tar</span><span class="delimiter">.</span><span class="function">push_back</span>(<span class="variable">pan</span>)<span class="delimiter">;</span>
}

<span class="comment">/* 求解汉诺塔问题 f(i) */</span>
<span class="type">void</span> <span class="function">dfs</span>(<span class="type">int</span> <span class="variable">i</span>, <span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">src</span>, <span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">buf</span>, <span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">tar</span>) {
    <span class="comment">// 若 src 只剩下一个圆盘，则直接将其移到 tar</span>
    <span class="keyword">if</span> (<span class="variable">i</span> <span class="operator">==</span> <span class="number">1</span>) {
        <span class="function">move</span>(<span class="variable">src</span>, <span class="variable">tar</span>)<span class="delimiter">;</span>
        <span class="keyword">return</span><span class="delimiter">;</span>
    }
    <span class="comment">// 子问题 f(i-1) ：将 src 顶部 i-1 个圆盘借助 tar 移到 buf</span>
    <span class="function">dfs</span>(<span class="variable">i</span> <span class="operator">-</span> <span class="number">1</span>, <span class="variable">src</span>, <span class="variable">tar</span>, <span class="variable">buf</span>)<span class="delimiter">;</span>
    <span class="comment">// 子问题 f(1) ：将 src 剩余一个圆盘移到 tar</span>
    <span class="function">move</span>(<span class="variable">src</span>, <span class="variable">tar</span>)<span class="delimiter">;</span>
    <span class="comment">// 子问题 f(i-1) ：将 buf 顶部 i-1 个圆盘借助 src 移到 tar</span>
    <span class="function">dfs</span>(<span class="variable">i</span> <span class="operator">-</span> <span class="number">1</span>, <span class="variable">buf</span>, <span class="variable">src</span>, <span class="variable">tar</span>)<span class="delimiter">;</span>
}

<span class="comment">/* 求解汉诺塔问题 */</span>
<span class="type">void</span> <span class="function">solveHanota</span>(<span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">A</span>, <span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">B</span>, <span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">C</span>) {
    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="variable">A</span><span class="delimiter">.</span><span class="function">size</span>()<span class="delimiter">;</span>
    <span class="comment">// 将 A 顶部 n 个圆盘借助 B 移到 C</span>
    <span class="function">dfs</span>(<span class="variable">n</span>, <span class="variable">A</span>, <span class="variable">B</span>, <span class="variable">C</span>)<span class="delimiter">;</span>
}
</code></pre>
<h3>回溯</h3><p>回溯的力量让我们能够重新开始,不断尝试,最终找到通往光明的出口.<br>回溯算法在尝试和回退中穷举所有可能的解,并通过剪枝避免不必要的搜索分支.<br>回溯算法通常采用”深度优先搜索”来遍历解空间</p><ol><li>全排列问题:暂略</li></ol><pre><code class="cpp"><span class="comment">/* 回溯算法：全排列 I */</span>
<span class="type">void</span> <span class="function">backtrack</span>(<span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">state</span>, <span class="keyword">const</span> <span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">choices</span>, <span class="type">vector</span><span class="operator">&lt;</span><span class="type">bool</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">selected</span>, <span class="type">vector</span><span class="operator">&lt;</span><span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">res</span>) {
    <span class="comment">// 当状态长度等于元素数量时，记录解</span>
    <span class="keyword">if</span> (<span class="variable">state</span><span class="delimiter">.</span><span class="function">size</span>() <span class="operator">==</span> <span class="variable">choices</span><span class="delimiter">.</span><span class="function">size</span>()) {
        <span class="variable">res</span><span class="delimiter">.</span><span class="function">push_back</span>(<span class="variable">state</span>)<span class="delimiter">;</span>
        <span class="keyword">return</span><span class="delimiter">;</span>
    }
    <span class="comment">// 遍历所有选择</span>
    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span><span class="delimiter">;</span> <span class="variable">i</span> <span class="operator">&lt;</span> <span class="variable">choices</span><span class="delimiter">.</span><span class="function">size</span>()<span class="delimiter">;</span> <span class="variable">i</span><span class="operator">++</span>) {
        <span class="type">int</span> <span class="variable">choice</span> <span class="operator">=</span> <span class="variable">choices</span>[<span class="variable">i</span>]<span class="delimiter">;</span>
        <span class="comment">// 剪枝：不允许重复选择元素</span>
        <span class="keyword">if</span> (!<span class="variable">selected</span>[<span class="variable">i</span>]) {
            <span class="comment">// 尝试：做出选择，更新状态</span>
            <span class="variable">selected</span>[<span class="variable">i</span>] <span class="operator">=</span> true<span class="delimiter">;</span>
            <span class="variable">state</span><span class="delimiter">.</span><span class="function">push_back</span>(<span class="variable">choice</span>)<span class="delimiter">;</span>
            <span class="comment">// 进行下一轮选择</span>
            <span class="function">backtrack</span>(<span class="variable">state</span>, <span class="variable">choices</span>, <span class="variable">selected</span>, <span class="variable">res</span>)<span class="delimiter">;</span>
            <span class="comment">// 回退：撤销选择，恢复到之前的状态</span>
            <span class="variable">selected</span>[<span class="variable">i</span>] <span class="operator">=</span> false<span class="delimiter">;</span>
            <span class="variable">state</span><span class="delimiter">.</span><span class="function">pop_back</span>()<span class="delimiter">;</span>
        }
    }
}

<span class="comment">/* 全排列 I */</span>
<span class="type">vector</span><span class="operator">&lt;</span><span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="function">permutationsI</span>(<span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="variable">nums</span>) {
    <span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="variable">state</span><span class="delimiter">;</span>
    <span class="type">vector</span><span class="operator">&lt;</span><span class="type">bool</span><span class="operator">&gt;</span> <span class="variable">selected</span>(<span class="variable">nums</span><span class="delimiter">.</span><span class="function">size</span>(), false)<span class="delimiter">;</span>
    <span class="type">vector</span><span class="operator">&lt;</span><span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="variable">res</span><span class="delimiter">;</span>
    <span class="function">backtrack</span>(<span class="variable">state</span>, <span class="variable">nums</span>, <span class="variable">selected</span>, <span class="variable">res</span>)<span class="delimiter">;</span>
    <span class="keyword">return</span> <span class="variable">res</span><span class="delimiter">;</span>
}
</code></pre>
<ol><li><p>子集和问题:暂略</p></li><li><p>N皇后问题:较复杂</p></li></ol><h3>动态规划:满足某种数列公式(状态转换方程)</h3><p>动态规划也对问题进行递归分解,但与分治算法的主要区别是,动态规划中的子问题是相互依赖的,在分解过程中会出现许多重叠子问题;<br>动态规划常用来求解最优化问题,特性:</p><ul><li>重叠子问题</li><li>最优子结构:</li><li>无后效性: 斐波那契数列f(n)=f(n-1)+f(n-2),n>1是典型的状态转移方程,适用动态规划</li></ul><ol><li>初探:状态转移方程</li></ol><pre><code class="cpp"><span class="comment">//给定一个共有n阶的楼梯，你每步可以上1阶或者2阶,请问有多少种方案可以爬到楼顶?</span>
<span class="comment">/* 爬楼梯：动态规划 */</span>
<span class="type">int</span> <span class="function">climbingStairsDP</span>(<span class="type">int</span> <span class="variable">n</span>) {
    <span class="keyword">if</span> (<span class="variable">n</span> <span class="operator">==</span> <span class="number">1</span> <span class="operator">||</span> <span class="variable">n</span> <span class="operator">==</span> <span class="number">2</span>)
        <span class="keyword">return</span> <span class="variable">n</span><span class="delimiter">;</span>
    <span class="comment">// 初始化 dp 表，用于存储子问题的解</span>
    <span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="variable">dp</span>(<span class="variable">n</span> <span class="operator">+</span> <span class="number">1</span>)<span class="delimiter">;</span>
    <span class="comment">// 初始状态：预设最小子问题的解</span>
    <span class="variable">dp</span>[<span class="number">1</span>] <span class="operator">=</span> <span class="number">1</span><span class="delimiter">;</span>
    <span class="variable">dp</span>[<span class="number">2</span>] <span class="operator">=</span> <span class="number">2</span><span class="delimiter">;</span>
    <span class="comment">// 状态转移：从较小子问题逐步求解较大子问题</span>
    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span><span class="delimiter">;</span> <span class="variable">i</span> &lt;= <span class="variable">n</span><span class="delimiter">;</span> <span class="variable">i</span><span class="operator">++</span>) {
        <span class="variable">dp</span>[<span class="variable">i</span>] <span class="operator">=</span> <span class="variable">dp</span>[<span class="variable">i</span> <span class="operator">-</span> <span class="number">1</span>] <span class="operator">+</span> <span class="variable">dp</span>[<span class="variable">i</span> <span class="operator">-</span> <span class="number">2</span>]<span class="delimiter">;</span><span class="comment">//状态转移方程</span>
    }
    <span class="keyword">return</span> <span class="variable">dp</span>[<span class="variable">n</span>]<span class="delimiter">;</span>
}

<span class="comment">/* 爬楼梯：空间优化后的动态规划 */</span>
<span class="type">int</span> <span class="function">climbingStairsDPComp</span>(<span class="type">int</span> <span class="variable">n</span>) {
    <span class="keyword">if</span> (<span class="variable">n</span> <span class="operator">==</span> <span class="number">1</span> <span class="operator">||</span> <span class="variable">n</span> <span class="operator">==</span> <span class="number">2</span>)
        <span class="keyword">return</span> <span class="variable">n</span><span class="delimiter">;</span>
    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span><span class="delimiter">;</span>
    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span><span class="delimiter">;</span> <span class="variable">i</span> &lt;= <span class="variable">n</span><span class="delimiter">;</span> <span class="variable">i</span><span class="operator">++</span>) {
        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="variable">b</span><span class="delimiter">;</span>
        <span class="variable">b</span> <span class="operator">=</span> <span class="variable">a</span> <span class="operator">+</span> <span class="variable">b</span><span class="delimiter">;</span>
        <span class="variable">a</span> <span class="operator">=</span> <span class="variable">tmp</span><span class="delimiter">;</span>
    }
    <span class="keyword">return</span> <span class="variable">b</span><span class="delimiter">;</span>
}
</code></pre>
<ol><li>0-1背包问题</li></ol><pre><code class="cpp"><span class="comment">//给定n个物品,第i个物品的重量为wgt[i],价值为val[i],和一个容量为cap的背包.每个物品只能选择一次,问在限定背包容量下能放入物品的最大价值</span>
<span class="comment">/* 0-1 背包：空间优化后的动态规划 */</span>
<span class="type">int</span> <span class="function">knapsackDPComp</span>(<span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">wgt</span>, <span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="variable">val</span>, <span class="type">int</span> <span class="variable">cap</span>) {
    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="variable">wgt</span><span class="delimiter">.</span><span class="function">size</span>()<span class="delimiter">;</span>
    <span class="comment">// 初始化 dp 表</span>
    <span class="type">vector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="variable">dp</span>(<span class="variable">cap</span> <span class="operator">+</span> <span class="number">1</span>, <span class="number">0</span>)<span class="delimiter">;</span>
    <span class="comment">// 状态转移</span>
    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span><span class="delimiter">;</span> <span class="variable">i</span> <span class="operator">&lt;</span> <span class="variable">n</span><span class="delimiter">;</span> <span class="variable">i</span><span class="operator">++</span>) {
        <span class="comment">// 倒序遍历</span>
        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="variable">cap</span><span class="delimiter">;</span> <span class="variable">c</span> &gt;= <span class="number">1</span><span class="delimiter">;</span> <span class="variable">c</span><span class="operator">--</span>) {
            <span class="keyword">if</span> (<span class="variable">wgt</span>[<span class="variable">i</span>] &lt;= <span class="variable">c</span>) {
                <span class="comment">// 不选和选物品 i 这两种方案的较大值</span>
                <span class="variable">dp</span>[<span class="variable">c</span>] <span class="operator">=</span> <span class="function">max</span>(<span class="variable">dp</span>[<span class="variable">c</span>], <span class="variable">dp</span>[<span class="variable">c</span> <span class="operator">-</span> <span class="variable">wgt</span>[<span class="variable">i</span>]] <span class="operator">+</span> <span class="variable">val</span>[<span class="variable">i</span>])<span class="delimiter">;</span>
            }
        }
    }
    <span class="keyword">return</span> <span class="variable">dp</span>[<span class="variable">cap</span>]<span class="delimiter">;</span>
}
</code></pre>
<ol><li>完全背包:(特例零钱兑换)物品可重复选取,不再仅1次或0次</li></ol><pre><code class="cpp"><span class="comment">//给定n个物品,第i个物品的重量为wgt[i-1],价值为val[i-1],和一个容量为cap的背包.每个物品可以重复选取,问在限定背包容量下能放入物品的最大价值.</span>
<span class="comment">/* 完全背包：空间优化后的动态规划 */</span>

<span class="comment">//给定n中硬币,第i中硬币的面值为coins[i-1],目标金额为amt,每种硬币可以重复选取,问能否凑出目标金额的最少硬币数量.如果无法凑出目标金额,则返回-1.</span>

<span class="comment">//给定n中硬币,第i中硬币的面值为coins[i-1],目标金额为amt,每种硬币可以重复选取,问凑出目标金额的硬币组合数量.</span>
</code></pre>
<h3>贪心算法:值得一试的捷径,有点魏延子午谷奇谋的意思</h3><p>贪心地做出局部最优的决策,以期获得全局最优解(近似算法捷径);不同于动态规划会根据之前阶段的所有决策来考虑当前决策(用过去子问题解构建当前子问题的解)<br>正确条件:每一步的最优解一定包含上一步的最优解</p><ol><li>零钱兑换：贪心 (精心设计的钱币对贪心算法有适配,否则动态规划才能达到最优)</li></ol><pre><code class="c"><span class="comment">/* 零钱兑换：贪心 */</span>
<span class="type">int</span> <span class="function">coinChangeGreedy</span>(<span class="type">int</span> <span class="operator">*</span><span class="variable">coins</span>, <span class="type">int</span> <span class="variable">size</span>, <span class="type">int</span> <span class="variable">amt</span>) {
    <span class="comment">// 假设 coins 列表有序</span>
    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="variable">size</span> <span class="operator">-</span> <span class="number">1</span><span class="delimiter">;</span>
    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span><span class="delimiter">;</span>
    <span class="comment">// 循环进行贪心选择，直到无剩余金额</span>
    <span class="keyword">while</span> (<span class="variable">amt</span> <span class="operator">&gt;</span> <span class="number">0</span>) {
        <span class="comment">// 找到小于且最接近剩余金额的硬币</span>
        <span class="keyword">while</span> (<span class="variable">i</span> <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> <span class="variable">coins</span>[<span class="variable">i</span>] <span class="operator">&gt;</span> <span class="variable">amt</span>) {
            <span class="variable">i</span><span class="operator">--</span><span class="delimiter">;</span>
        }
        <span class="comment">// 选择 coins[i]</span>
        <span class="variable">amt</span> <span class="operator">-=</span> <span class="variable">coins</span>[<span class="variable">i</span>]<span class="delimiter">;</span>
        <span class="variable">count</span><span class="operator">++</span><span class="delimiter">;</span>
    }
    <span class="comment">// 若未找到可行方案，则返回 -1</span>
    <span class="keyword">return</span> <span class="variable">amt</span> <span class="operator">==</span> <span class="number">0</span> ? <span class="variable">count</span> : <span class="number">-1</span><span class="delimiter">;</span>
}
</code></pre>
<ol><li>分数背包问题</li></ol></div>
</body>
</html>
