---
.title="设计模式",
.date=@date("2024-11-22T00:00:00"),
.author="let2rs",
.layout="home.shtml",
.draft=false,
---
## [UML类图](https://design-patterns.readthedocs.io/zh_CN/latest/index.html)
### 实现
继承抽象类,虚线三角(被指向者是基类)

### 泛化
继承普通类,实线三角(被指向者是基类)

### 依赖
使用,通常作参数/局部变量/全局变量,虚线箭头(被指向者是参数)

### 关联
使用,通常作属性(成员变量),个体与个体的平级关系(区别于聚合和组合的个体与整体的关系),实线箭头

### 聚合
使用,作属性,外部独立对象传参构造,可脱离,空心菱形(一般和关联箭头方向相反)

### 组合
使用,作属性,局部构造,不可脱离,实心菱形(一般和关联箭头方向相反)

## [设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/index.html)
1. 聚合接口:
- 接口类聚合接口继承链(桥接模式);
- 派生类聚合接口继承链(对象适配器模式);
- 普通类聚合接口继承链(建造者模式,策略模式,状态模式);
2. xxx

### 单例模式:创建型模式
单例模式本质是某命名空间下的全局变量;渐渐被依赖注入所替代
```cpp
//单例模式-局部静态变量:禁用拷贝构造赋值,私有默认构造和析构
class Singleton {
public:
	static Singleton& getInstance(){
		static Singleton instance;
		return instance;
	}
private:
	Singleton ()= default;
	~Singleton ()= default;
	Singleton (const Singleton &)= delete;
	Singleton & operator=(const Singleton &)= delete;
};
```
### 原型模式
类似Abstract* clone()方法,返回克隆的基类指针等

### 建造者模式
典型的聚合关系,抽象类建造者作属性,且建造者作方法参数,参数再泛化具体建造者

### 简单工厂模式
根据既定参数不同,在工厂方法中直接new继承链中的派生类,返回基类指针

### 工厂方法模式
在简单工厂的基础上将new移到派生工厂类的方法中,同样返回产品的基类指针

### 抽象工厂模式
在工厂方法的基础上,新增另一个派生类工厂类方法,以生产另一类产品,使工厂生产多样化(水平扩展)

### 适配器模式:结构型模式
对象适配器:类似聚合,但实际是关联关系;使用(依赖)适配基类,适配派生类关联另一类适配者到属性(对象),方法中传入新适配者的指针(以设定对象):在原有7字依赖-继承链的底端派生类,关联(类聚合方式)新适配者

类适配器:在对象基础上,调整派生适配器继承新适配器:在原有7字依赖-继承链的底端,继承(泛化)新适配者

### 桥接模式
早期阶段接口模式,后期灵活调整为适配器模式:在原有7字依赖-继承链的拐点接口处,聚合新接口(新继承链)

### 组合模式
容器如vector<Base*>作类的私有成员属性

### 装饰模式
派生类聚合子派生类,此处类型是基类的指针

### 外观模式
普通类组合多个类,将多个类作属性

### 享元模式
继承链的基类指针在类中形式:map<string,Base*>

### 代理模式
继承链的同级之间,组合式关联对方,从而代理对方<br>又继承链的兄弟之间,组合式关联兄弟节点

### 策略模式:行为型模式
典型的聚合关系,抽象类策略作属性,且策略指针作方法参数,参数再泛化具体策略

### 状态模式
典型的聚合关系

### 观察者模式
对象继承链基类聚合观察者继承链的基类,观察者的派生类聚合对象的派生类,成环

### 命令模式
调用者聚合命令树的基类,派生命令聚合某执行者

### 迭代器模式
容器继承链的抽象类和派生类分别依赖迭代器继承链的抽象类和派生类,但迭代器派生类聚合式关联容器派生类

### 责任链模式
继承链的接口聚合自身,set和get呈链式

### 模板方法模式
接口中某方法调用纯虚函数(集合其它虚函数),派生类实现虚函数

